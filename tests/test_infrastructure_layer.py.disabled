"""Comprehensive tests for infrastructure layer - 100% coverage target.

Tests all infrastructure components with complete coverage:
- Repositories: pipeline, plugin, user repositories
- Ports: authentication, external service ports
- Database: connection, session management
- External integrations: flext-auth, flext-plugin platforms
"""

from __future__ import annotations

from datetime import UTC, datetime
from typing import TYPE_CHECKING, Any
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from flext_core import FlextResult
from sqlalchemy.ext.asyncio import AsyncSession

from flext_api.domain.models.pipeline import FlextPipeline, PipelineStatus
from flext_api.domain.models.plugin import FlextPlugin, PluginStatus
from flext_api.infrastructure.database.session import get_db_session
from flext_api.infrastructure.ports import FlextJWTAuthService
from flext_api.infrastructure.repositories.pipeline_repository import PipelineRepository
from flext_api.infrastructure.repositories.plugin_repository import PluginRepository

if TYPE_CHECKING:
    from collections.abc import AsyncGenerator


class TestPipelineRepository:
    """Complete test coverage for PipelineRepository - target 95%+."""

    @pytest.fixture
    async def pipeline_repository(self) -> AsyncGenerator[PipelineRepository]:
        """Create PipelineRepository instance for testing."""
        # Mock database session
        mock_session = AsyncMock(spec=AsyncSession)
        with patch(
            "flext_api.infrastructure.repositories.pipeline_repository.get_db_session",
            return_value=mock_session,
        ):
            repository = PipelineRepository()
            yield repository

    async def test_create_pipeline_success(
        self, pipeline_repository: PipelineRepository
    ) -> None:
        """Test successful pipeline creation."""
        pipeline_data = {
            "name": "test-pipeline",
            "description": "Test pipeline",
            "config": {"tap": "tap-postgres", "target": "target-jsonl"},
        }

        # Mock successful database creation
        mock_pipeline = FlextPipeline(
            id="test-id",
            name="test-pipeline",
            description="Test pipeline",
            config={"tap": "tap-postgres", "target": "target-jsonl"},
            status=PipelineStatus.CREATED,
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
        )

        with patch.object(
            pipeline_repository, "_create_db_entry", return_value=mock_pipeline
        ):
            result = await pipeline_repository.create(pipeline_data)

            assert result is not None
            assert result.name == "test-pipeline"
            assert result.status == PipelineStatus.CREATED

    async def test_create_pipeline_failure(
        self, pipeline_repository: PipelineRepository
    ) -> None:
        """Test pipeline creation failure."""
        pipeline_data = {"name": "test-pipeline"}

        with patch.object(
            pipeline_repository,
            "_create_db_entry",
            side_effect=ValueError("Database error"),
        ), pytest.raises(ValueError, match="Database error"):
            await pipeline_repository.create(pipeline_data)

    async def test_get_by_id_success(
        self, pipeline_repository: PipelineRepository
    ) -> None:
        """Test successful pipeline retrieval by ID."""
        pipeline_id = "test-id"
        mock_pipeline = FlextPipeline(
            id=pipeline_id,
            name="test-pipeline",
            description="Test pipeline",
            config={},
            status=PipelineStatus.CREATED,
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
        )

        with patch.object(
            pipeline_repository, "_get_db_entry", return_value=mock_pipeline
        ):
            result = await pipeline_repository.get_by_id(pipeline_id)

            assert result is not None
            assert result.id == pipeline_id

    async def test_get_by_id_not_found(
        self, pipeline_repository: PipelineRepository
    ) -> None:
        """Test pipeline retrieval for non-existent ID."""
        pipeline_id = "nonexistent-id"

        with patch.object(pipeline_repository, "_get_db_entry", return_value=None):
            result = await pipeline_repository.get_by_id(pipeline_id)

            assert result is None

    async def test_list_all_success(
        self, pipeline_repository: PipelineRepository
    ) -> None:
        """Test successful pipeline listing."""
        mock_pipelines = [
            FlextPipeline(
                id="id1",
                name="pipeline1",
                description="Test pipeline 1",
                config={},
                status=PipelineStatus.CREATED,
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            ),
            FlextPipeline(
                id="id2",
                name="pipeline2",
                description="Test pipeline 2",
                config={},
                status=PipelineStatus.RUNNING,
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            ),
        ]

        with patch.object(
            pipeline_repository, "_list_db_entries", return_value=mock_pipelines
        ):
            result = await pipeline_repository.list_all()

            assert len(result) == 2
            assert result[0].name == "pipeline1"
            assert result[1].name == "pipeline2"

    async def test_update_success(
        self, pipeline_repository: PipelineRepository
    ) -> None:
        """Test successful pipeline update."""
        pipeline_id = "test-id"
        updates = {"description": "Updated description"}

        mock_pipeline = FlextPipeline(
            id=pipeline_id,
            name="test-pipeline",
            description="Updated description",
            config={},
            status=PipelineStatus.CREATED,
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
        )

        with patch.object(
            pipeline_repository, "_update_db_entry", return_value=mock_pipeline
        ):
            result = await pipeline_repository.update(pipeline_id, updates)

            assert result is not None
            assert result.description == "Updated description"

    async def test_delete_success(
        self, pipeline_repository: PipelineRepository
    ) -> None:
        """Test successful pipeline deletion."""
        pipeline_id = "test-id"

        with patch.object(pipeline_repository, "_delete_db_entry", return_value=True):
            result = await pipeline_repository.delete(pipeline_id)

            assert result is True

    async def test_delete_not_found(
        self, pipeline_repository: PipelineRepository
    ) -> None:
        """Test pipeline deletion for non-existent ID."""
        pipeline_id = "nonexistent-id"

        with patch.object(pipeline_repository, "_delete_db_entry", return_value=False):
            result = await pipeline_repository.delete(pipeline_id)

            assert result is False

    async def test_get_by_name_success(
        self, pipeline_repository: PipelineRepository
    ) -> None:
        """Test successful pipeline retrieval by name."""
        pipeline_name = "test-pipeline"
        mock_pipeline = FlextPipeline(
            id="test-id",
            name=pipeline_name,
            description="Test pipeline",
            config={},
            status=PipelineStatus.CREATED,
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
        )

        with patch.object(
            pipeline_repository, "_get_db_entry_by_field", return_value=mock_pipeline
        ):
            result = await pipeline_repository.get_by_name(pipeline_name)

            assert result is not None
            assert result.name == pipeline_name

    async def test_get_by_status_success(
        self, pipeline_repository: PipelineRepository
    ) -> None:
        """Test successful pipeline retrieval by status."""
        status = PipelineStatus.RUNNING
        mock_pipelines = [
            FlextPipeline(
                id="id1",
                name="pipeline1",
                description="Running pipeline 1",
                config={},
                status=PipelineStatus.RUNNING,
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            ),
        ]

        with patch.object(
            pipeline_repository,
            "_list_db_entries_by_field",
            return_value=mock_pipelines,
        ):
            result = await pipeline_repository.get_by_status(status)

            assert len(result) == 1
            assert result[0].status == PipelineStatus.RUNNING


class TestPluginRepository:
    """Complete test coverage for PluginRepository - target 95%+."""

    @pytest.fixture
    async def plugin_repository(self) -> AsyncGenerator[PluginRepository]:
        """Create PluginRepository instance for testing."""
        mock_session = AsyncMock(spec=AsyncSession)
        with patch(
            "flext_api.infrastructure.repositories.plugin_repository.get_db_session",
            return_value=mock_session,
        ):
            repository = PluginRepository()
            yield repository

    async def test_create_plugin_success(
        self, plugin_repository: PluginRepository
    ) -> None:
        """Test successful plugin creation."""
        plugin_data = {
            "name": "tap-postgres",
            "version": "1.0.0",
            "plugin_type": "tap",
            "config": {"host": "localhost", "port": 5432},
        }

        mock_plugin = FlextPlugin(
            id="test-id",
            name="tap-postgres",
            version="1.0.0",
            plugin_type="tap",
            status=PluginStatus.INSTALLED,
            config={"host": "localhost", "port": 5432},
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
        )

        with patch.object(
            plugin_repository, "_create_db_entry", return_value=mock_plugin
        ):
            result = await plugin_repository.create(plugin_data)

            assert result is not None
            assert result.name == "tap-postgres"
            assert result.plugin_type == "tap"

    async def test_get_by_name_and_version_success(
        self, plugin_repository: PluginRepository
    ) -> None:
        """Test successful plugin retrieval by name and version."""
        plugin_name = "tap-postgres"
        plugin_version = "1.0.0"

        mock_plugin = FlextPlugin(
            id="test-id",
            name=plugin_name,
            version=plugin_version,
            plugin_type="tap",
            status=PluginStatus.INSTALLED,
            config={},
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
        )

        with patch.object(
            plugin_repository, "_get_db_entry_by_fields", return_value=mock_plugin
        ):
            result = await plugin_repository.get_by_name_and_version(
                plugin_name, plugin_version
            )

            assert result is not None
            assert result.name == plugin_name
            assert result.version == plugin_version

    async def test_list_by_type_success(
        self, plugin_repository: PluginRepository
    ) -> None:
        """Test successful plugin listing by type."""
        plugin_type = "tap"
        mock_plugins = [
            FlextPlugin(
                id="id1",
                name="tap-postgres",
                version="1.0.0",
                plugin_type="tap",
                status=PluginStatus.INSTALLED,
                config={},
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            ),
            FlextPlugin(
                id="id2",
                name="tap-mysql",
                version="2.0.0",
                plugin_type="tap",
                status=PluginStatus.AVAILABLE,
                config={},
                created_at=datetime.now(UTC),
                updated_at=datetime.now(UTC),
            ),
        ]

        with patch.object(
            plugin_repository, "_list_db_entries_by_field", return_value=mock_plugins
        ):
            result = await plugin_repository.list_by_type(plugin_type)

            assert len(result) == 2
            assert all(plugin.plugin_type == "tap" for plugin in result)

    async def test_update_status_success(
        self, plugin_repository: PluginRepository
    ) -> None:
        """Test successful plugin status update."""
        plugin_id = "test-id"
        new_status = PluginStatus.RUNNING

        mock_plugin = FlextPlugin(
            id=plugin_id,
            name="tap-postgres",
            version="1.0.0",
            plugin_type="tap",
            status=new_status,
            config={},
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
        )

        with patch.object(
            plugin_repository, "_update_db_entry", return_value=mock_plugin
        ):
            result = await plugin_repository.update_status(plugin_id, new_status)

            assert result is not None
            assert result.status == new_status


class TestFlextJWTAuthService:
    """Complete test coverage for FlextJWTAuthService - target 95%+."""

    @pytest.fixture
    def auth_service(self) -> FlextJWTAuthService:
        """Create FlextJWTAuthService instance for testing."""
        from flext_api.config import get_api_settings

        settings = get_api_settings()
        return FlextJWTAuthService(settings)

    async def test_authenticate_user_success(
        self, auth_service: FlextJWTAuthService
    ) -> None:
        """Test successful user authentication."""
        username = "admin"
        password = "admin123"

        result = await auth_service.authenticate_user(username, password)

        assert result.success is True
        assert result.value["username"] == username
        assert result.value["authenticated"] is True
        assert "roles" in result.value

    async def test_authenticate_user_invalid_credentials(
        self, auth_service: FlextJWTAuthService
    ) -> None:
        """Test authentication with invalid credentials."""
        username = "invalid"
        password = "invalid"

        result = await auth_service.authenticate_user(username, password)

        assert result.success is False
        assert "Invalid credentials" in result.error

    async def test_authenticate_user_missing_username(
        self, auth_service: FlextJWTAuthService
    ) -> None:
        """Test authentication with missing username."""
        username = "nonexistent"
        password = "password"

        result = await auth_service.authenticate_user(username, password)

        assert result.success is False
        assert "Invalid credentials" in result.error

    async def test_authenticate_user_wrong_password(
        self, auth_service: FlextJWTAuthService
    ) -> None:
        """Test authentication with wrong password."""
        username = "admin"
        password = "wrongpassword"

        result = await auth_service.authenticate_user(username, password)

        assert result.success is False
        assert "Invalid credentials" in result.error

    async def test_generate_token_success(
        self, auth_service: FlextJWTAuthService
    ) -> None:
        """Test successful token generation."""
        user_data = {
            "username": "testuser",
            "roles": ["user"],
            "is_admin": False,
        }

        with patch(
            "flext_api.infrastructure.ports.jwt.encode", return_value="mock_token"
        ):
            result = await auth_service.generate_token(user_data)

            assert result.success is True
            assert result.value == "mock_token"

    async def test_generate_token_failure(
        self, auth_service: FlextJWTAuthService
    ) -> None:
        """Test token generation failure."""
        user_data = {"username": "testuser"}

        with patch(
            "flext_api.infrastructure.ports.jwt.encode",
            side_effect=ValueError("Token error"),
        ):
            result = await auth_service.generate_token(user_data)

            assert result.success is False
            assert "Token generation failed" in result.error

    async def test_validate_token_success(
        self, auth_service: FlextJWTAuthService
    ) -> None:
        """Test successful token validation."""
        token = "valid_token"
        mock_payload = {"username": "testuser", "roles": ["user"]}

        with patch(
            "flext_api.infrastructure.ports.jwt.decode", return_value=mock_payload
        ):
            result = await auth_service.validate_token(token)

            assert result.success is True
            assert result.value["username"] == "testuser"

    async def test_validate_token_invalid(
        self, auth_service: FlextJWTAuthService
    ) -> None:
        """Test token validation with invalid token."""
        token = "invalid_token"

        with patch(
            "flext_api.infrastructure.ports.jwt.decode",
            side_effect=ValueError("Invalid token"),
        ):
            result = await auth_service.validate_token(token)

            assert result.success is False
            assert "Token validation failed" in result.error

    async def test_validate_token_expired(
        self, auth_service: FlextJWTAuthService
    ) -> None:
        """Test token validation with expired token."""
        token = "expired_token"

        from jwt import ExpiredSignatureError

        with patch(
            "flext_api.infrastructure.ports.jwt.decode",
            side_effect=ExpiredSignatureError(),
        ):
            result = await auth_service.validate_token(token)

            assert result.success is False
            assert "Token expired" in result.error


class TestDatabaseSession:
    """Complete test coverage for database session management - target 95%+."""

    async def test_get_db_session_success(self) -> None:
        """Test successful database session creation."""
        with patch(
            "flext_api.infrastructure.database.session.async_session_factory"
        ) as mock_factory:
            mock_session = AsyncMock(spec=AsyncSession)
            mock_factory.return_value.__aenter__.return_value = mock_session
            mock_factory.return_value.__aexit__.return_value = None

            async with get_db_session() as session:
                assert session is mock_session

    async def test_get_db_session_failure(self) -> None:
        """Test database session creation failure."""
        with patch(
            "flext_api.infrastructure.database.session.async_session_factory"
        ) as mock_factory:
            mock_factory.return_value.__aenter__.side_effect = RuntimeError(
                "Database connection failed"
            )

            with pytest.raises(RuntimeError, match="Database connection failed"):
                async with get_db_session():
                    pass

    async def test_session_rollback_on_exception(self) -> None:
        """Test session rollback on exception."""
        with patch(
            "flext_api.infrastructure.database.session.async_session_factory"
        ) as mock_factory:
            mock_session = AsyncMock(spec=AsyncSession)
            mock_factory.return_value.__aenter__.return_value = mock_session
            mock_factory.return_value.__aexit__.return_value = None

            try:
                async with get_db_session() as session:
                    assert session is mock_session
                    # Simulate an exception
                    raise ValueError("Test exception")
            except ValueError:
                pass

            # Verify rollback was called (through context manager)
            mock_factory.return_value.__aexit__.assert_called_once()


class TestExternalIntegrations:
    """Test external service integrations - target 95%+."""

    async def test_flext_auth_platform_initialization(self) -> None:
        """Test FlextAuthPlatform initialization."""
        with patch(
            "flext_api.application.services.auth_service.FlextAuthPlatform"
        ) as mock_platform:
            mock_instance = MagicMock()
            mock_platform.return_value = mock_instance
            mock_instance.initialize.return_value = None

            from flext_api.application.services.auth_service import AuthService

            service = AuthService()
            await service.initialize()

            mock_platform.assert_called_once()
            mock_instance.initialize.assert_called_once()

    async def test_flext_plugin_platform_initialization(self) -> None:
        """Test FlextPluginPlatform initialization."""
        with patch(
            "flext_api.application.services.plugin_service.FlextPluginPlatform"
        ) as mock_platform:
            mock_instance = MagicMock()
            mock_platform.return_value = mock_instance
            mock_instance.initialize.return_value = None

            from flext_api.application.services.plugin_service import PluginService

            service = PluginService()
            await service.initialize()

            mock_platform.assert_called_once()
            mock_instance.initialize.assert_called_once()

    async def test_auth_platform_unavailable(self) -> None:
        """Test handling when FlextAuthPlatform is unavailable."""
        with patch(
            "flext_api.application.services.auth_service.FlextAuthPlatform",
            side_effect=ImportError("Not available"),
        ):
            from flext_api.application.services.auth_service import AuthService

            service = AuthService()

            with pytest.raises(ImportError, match="Not available"):
                await service.initialize()

    async def test_plugin_platform_unavailable(self) -> None:
        """Test handling when FlextPluginPlatform is unavailable."""
        with patch(
            "flext_api.application.services.plugin_service.FlextPluginPlatform",
            side_effect=ImportError("Not available"),
        ):
            from flext_api.application.services.plugin_service import PluginService

            service = PluginService()

            with pytest.raises(ImportError, match="Not available"):
                await service.initialize()


class TestErrorHandling:
    """Test error handling across infrastructure layer - target 95%+."""

    async def test_database_connection_error(self) -> None:
        """Test database connection error handling."""
        with patch(
            "flext_api.infrastructure.database.session.create_async_engine",
            side_effect=RuntimeError("DB error"),
        ), pytest.raises(RuntimeError, match="DB error"):
            from flext_api.infrastructure.database.session import engine

    async def test_repository_transaction_error(self) -> None:
        """Test repository transaction error handling."""
        mock_session = AsyncMock(spec=AsyncSession)
        mock_session.commit.side_effect = RuntimeError("Commit failed")

        from flext_api.infrastructure.repositories.pipeline_repository import (
            PipelineRepository,
        )

        repository = PipelineRepository()

        with (
            patch.object(repository, "_get_session", return_value=mock_session),
            pytest.raises(RuntimeError, match="Commit failed"),
        ):
            await repository.create({"name": "test"})

    async def test_auth_service_connection_error(self) -> None:
        """Test authentication service connection error."""
        from flext_api.config import get_api_settings

        settings = get_api_settings()
        auth_service = FlextJWTAuthService(settings)

        # Mock network error during authentication
        with patch.object(
            auth_service,
            "_validate_credentials",
            side_effect=ConnectionError("Network error"),
        ):
            result = await auth_service.authenticate_user("user", "pass")

            assert result.success is False
            assert "Network error" in result.error
