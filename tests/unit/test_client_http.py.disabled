"""Tests for HTTP client functionality."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from unittest.mock import MagicMock
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from flext_api.client import (
    FlextApiCachingPlugin,
    FlextApiCircuitBreakerPlugin,
    FlextApiClient,
    FlextApiClientConfig,
    FlextApiClientMethod,
    FlextApiClientRequest,
    FlextApiRetryPlugin,
)


class TestFlextApiClientHTTP:
    """Test HTTP client functionality."""

    @pytest.mark.asyncio
    @patch("aiohttp.ClientSession")
    async def test_get_request(self, mock_session_class: MagicMock) -> None:
        """Test GET request."""
        # Mock the session and response properly
        mock_session = AsyncMock()
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.headers = {}
        mock_response.json = AsyncMock(return_value={"success": True})

        # Mock the async context manager properly
        mock_context_manager = MagicMock()
        mock_context_manager.__aenter__ = AsyncMock(return_value=mock_response)
        mock_context_manager.__aexit__ = AsyncMock(return_value=None)
        mock_session.request.return_value = mock_context_manager
        mock_session_class.return_value = mock_session

        client = FlextApiClient()
        result = await client.get("/test")

        assert result.is_success is True
        response = result.data
        assert response.status_code == 200

    @pytest.mark.asyncio
    @patch("aiohttp.ClientSession")
    async def test_post_request(self, mock_session_class: MagicMock) -> None:
        """Test POST request."""
        mock_session = AsyncMock()
        mock_response = AsyncMock()
        mock_response.status = 201
        mock_response.headers = {}
        mock_response.json = AsyncMock(return_value={"created": True})

        # Mock the async context manager properly
        mock_context_manager = MagicMock()
        mock_context_manager.__aenter__ = AsyncMock(return_value=mock_response)
        mock_context_manager.__aexit__ = AsyncMock(return_value=None)
        mock_session.request.return_value = mock_context_manager
        mock_session_class.return_value = mock_session

        client = FlextApiClient()
        result = await client.post("/test", json_data={"key": "value"})

        assert result.is_success is True
        response = result.data
        assert response.status_code == 201

    @pytest.mark.asyncio
    @patch("aiohttp.ClientSession")
    async def test_put_request(self, mock_session_class: MagicMock) -> None:
        """Test PUT request."""
        mock_session = AsyncMock()
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.headers = {}
        mock_response.json = AsyncMock(return_value={"updated": True})

        # Mock the async context manager properly
        mock_context_manager = MagicMock()
        mock_context_manager.__aenter__ = AsyncMock(return_value=mock_response)
        mock_context_manager.__aexit__ = AsyncMock(return_value=None)
        mock_session.request.return_value = mock_context_manager
        mock_session_class.return_value = mock_session

        client = FlextApiClient()
        result = await client.put("/test", json_data={"key": "value"})

        assert result.is_success is True

    @pytest.mark.asyncio
    @patch("aiohttp.ClientSession")
    async def test_delete_request(self, mock_session_class: MagicMock) -> None:
        """Test DELETE request."""
        mock_session = AsyncMock()
        mock_response = AsyncMock()
        mock_response.status = 204
        mock_response.headers = {}
        mock_response.json = AsyncMock(return_value={})

        # Mock the async context manager properly
        mock_context_manager = MagicMock()
        mock_context_manager.__aenter__ = AsyncMock(return_value=mock_response)
        mock_context_manager.__aexit__ = AsyncMock(return_value=None)
        mock_session.request.return_value = mock_context_manager
        mock_session_class.return_value = mock_session

        client = FlextApiClient()
        result = await client.delete("/test")

        assert result.is_success is True

    @pytest.mark.asyncio
    @patch("aiohttp.ClientSession")
    async def test_request_with_base_url(self, mock_session_class: MagicMock) -> None:
        """Test request with base URL configuration."""
        mock_session = AsyncMock()
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.headers = {}
        mock_response.json = AsyncMock(return_value={})

        # Mock the async context manager properly
        mock_context_manager = MagicMock()
        mock_context_manager.__aenter__ = AsyncMock(return_value=mock_response)
        mock_context_manager.__aexit__ = AsyncMock(return_value=None)
        mock_session.request.return_value = mock_context_manager
        mock_session_class.return_value = mock_session

        config = FlextApiClientConfig(base_url="https://api.example.com")
        client = FlextApiClient(config)

        await client.get("/test")

        # Verify the full URL was used
        mock_session.request.assert_called_once()
        args = mock_session.request.call_args
        assert "https://api.example.com/test" in str(args)

    @pytest.mark.asyncio
    @patch("aiohttp.ClientSession")
    async def test_request_with_plugins(self, mock_session_class: MagicMock) -> None:
        """Test request with plugins."""
        mock_session = AsyncMock()
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.headers = {}
        mock_response.json = AsyncMock(return_value={})

        # Mock the async context manager properly
        mock_context_manager = MagicMock()
        mock_context_manager.__aenter__ = AsyncMock(return_value=mock_response)
        mock_context_manager.__aexit__ = AsyncMock(return_value=None)
        mock_session.request.return_value = mock_context_manager
        mock_session_class.return_value = mock_session

        # Create a mock plugin
        mock_plugin = AsyncMock()
        mock_plugin.enabled = True
        mock_plugin.before_request.return_value = FlextApiClientRequest(
            method=FlextApiClientMethod.GET,
            url="/test",
        )
        mock_plugin.after_request.return_value = MagicMock()

        client = FlextApiClient(plugins=[mock_plugin])
        await client.get("/test")

        # Plugin methods should have been called
        mock_plugin.before_request.assert_called_once()
        mock_plugin.after_request.assert_called_once()

    @pytest.mark.asyncio
    async def test_request_error_handling(self) -> None:
        """Test request error handling."""
        client = FlextApiClient()

        # Mock the _make_request_impl to raise an exception
        test_error = Exception("Test error")
        with patch.object(client, "_make_request_impl", side_effect=test_error):
            result = await client._make_request(FlextApiClientRequest(
                method=FlextApiClientMethod.GET,
                url="/test",
            ))

            assert result.is_success is False
            assert "Test error" in result.error

    def test_client_enums(self) -> None:
        """Test client enumeration values."""
        # Test method enum
        assert FlextApiClientMethod.GET == "GET"
        assert FlextApiClientMethod.POST == "POST"
        assert FlextApiClientMethod.PUT == "PUT"
        assert FlextApiClientMethod.DELETE == "DELETE"
        assert FlextApiClientMethod.PATCH == "PATCH"
        assert FlextApiClientMethod.HEAD == "HEAD"
        assert FlextApiClientMethod.OPTIONS == "OPTIONS"


class TestFlextApiPlugins:
    """Test plugin functionality."""

    def test_caching_plugin_creation(self) -> None:
        """Test creating caching plugin."""
        plugin = FlextApiCachingPlugin()
        assert plugin.name == "CachingPlugin"
        assert plugin.ttl == 300
        assert plugin.max_size == 1000

    def test_caching_plugin_with_params(self) -> None:
        """Test creating caching plugin with parameters."""
        plugin = FlextApiCachingPlugin(ttl=600, max_size=2000)
        assert plugin.ttl == 600
        assert plugin.max_size == 2000

    @pytest.mark.asyncio
    async def test_caching_plugin_before_request(self) -> None:
        """Test caching plugin before request."""
        plugin = FlextApiCachingPlugin()
        request = FlextApiClientRequest(
            method=FlextApiClientMethod.GET,
            url="/test",
            params={"key": "value"},
        )

        result = await plugin.before_request(request)
        assert result == request

    def test_retry_plugin_creation(self) -> None:
        """Test creating retry plugin."""
        plugin = FlextApiRetryPlugin()
        assert plugin.name == "RetryPlugin"
        assert plugin.max_retries == 3
        assert plugin.backoff_factor == 2.0

    def test_retry_plugin_with_params(self) -> None:
        """Test creating retry plugin with parameters."""
        plugin = FlextApiRetryPlugin(max_retries=5, backoff_factor=1.5)
        assert plugin.max_retries == 5
        assert plugin.backoff_factor == 1.5

    def test_circuit_breaker_plugin_creation(self) -> None:
        """Test creating circuit breaker plugin."""
        plugin = FlextApiCircuitBreakerPlugin()
        assert plugin.name == "CircuitBreakerPlugin"
        assert plugin.failure_threshold == 5
        assert plugin.recovery_timeout == 60
        assert plugin.failure_count == 0
        assert plugin.state == "CLOSED"

    def test_circuit_breaker_plugin_with_params(self) -> None:
        """Test creating circuit breaker plugin with parameters."""
        plugin = FlextApiCircuitBreakerPlugin(
            failure_threshold=10, recovery_timeout=120,
        )
        assert plugin.failure_threshold == 10
        assert plugin.recovery_timeout == 120
