"""Comprehensive tests for domain layer - 100% coverage target.

Tests all domain models, entities, and value objects:
- Pipeline domain models: FlextPipeline, PipelineStatus, validation
- Plugin domain models: FlextPlugin, PluginStatus, plugin types
- User domain models: User entities, roles, permissions
- Value objects: configuration, metadata, timestamps
- Domain services: business logic, validation rules
"""

from __future__ import annotations

from datetime import UTC, datetime
from typing import Any

import pytest
from pydantic import ValidationError

from flext_api.domain.models.pipeline import FlextPipeline, PipelineStatus
from flext_api.domain.models.plugin import FlextPlugin, PluginStatus, PluginType
from flext_api.models.auth import LoginRequest, TokenResponse, UserResponse
from flext_api.models.pipeline import (
    PipelineCreateRequest,
    PipelineResponse,
    PipelineUpdateRequest,
)
from flext_api.models.plugin import (
    PluginInstallationRequest,
    PluginInstallationResponse,
    PluginResponse,
    PluginSource,
)
from flext_api.models.system import HealthResponse, MetricsResponse


class TestPipelineDomainModels:
    """Complete test coverage for pipeline domain models - target 95%+."""

    def test_flext_pipeline_creation_success(self) -> None:
        """Test successful FlextPipeline creation."""
        pipeline_data = {
            "id": "test-id",
            "name": "test-pipeline",
            "description": "Test pipeline description",
            "config": {"tap": "tap-postgres", "target": "target-jsonl"},
            "status": PipelineStatus.CREATED,
            "created_at": datetime.now(UTC),
            "updated_at": datetime.now(UTC),
        }

        pipeline = FlextPipeline(**pipeline_data)

        assert pipeline.id == "test-id"
        assert pipeline.name == "test-pipeline"
        assert pipeline.description == "Test pipeline description"
        assert pipeline.config == {"tap": "tap-postgres", "target": "target-jsonl"}
        assert pipeline.status == PipelineStatus.CREATED
        assert isinstance(pipeline.created_at, datetime)
        assert isinstance(pipeline.updated_at, datetime)

    def test_flext_pipeline_validation_errors(self) -> None:
        """Test FlextPipeline validation errors."""
        # Test missing required fields
        with pytest.raises(ValidationError) as exc_info:
            FlextPipeline()

        errors = exc_info.value.errors()
        required_fields = {
            "id",
            "name",
            "description",
            "config",
            "status",
            "created_at",
            "updated_at",
        }
        error_fields = {error["loc"][0] for error in errors}
        assert required_fields.issubset(error_fields)

    def test_flext_pipeline_invalid_status(self) -> None:
        """Test FlextPipeline with invalid status."""
        pipeline_data = {
            "id": "test-id",
            "name": "test-pipeline",
            "description": "Test pipeline",
            "config": {},
            "status": "invalid_status",  # Invalid status
            "created_at": datetime.now(UTC),
            "updated_at": datetime.now(UTC),
        }

        with pytest.raises(ValidationError) as exc_info:
            FlextPipeline(**pipeline_data)

        assert "status" in str(exc_info.value)

    def test_flext_pipeline_empty_name(self) -> None:
        """Test FlextPipeline with empty name."""
        pipeline_data = {
            "id": "test-id",
            "name": "",  # Empty name
            "description": "Test pipeline",
            "config": {},
            "status": PipelineStatus.CREATED,
            "created_at": datetime.now(UTC),
            "updated_at": datetime.now(UTC),
        }

        with pytest.raises(ValidationError) as exc_info:
            FlextPipeline(**pipeline_data)

        assert "name" in str(exc_info.value)

    def test_pipeline_status_enum_values(self) -> None:
        """Test PipelineStatus enum values."""
        assert PipelineStatus.CREATED == "created"
        assert PipelineStatus.RUNNING == "running"
        assert PipelineStatus.COMPLETED == "completed"
        assert PipelineStatus.FAILED == "failed"
        assert PipelineStatus.CANCELLED == "cancelled"

    def test_pipeline_status_string_conversion(self) -> None:
        """Test PipelineStatus string conversion."""
        assert str(PipelineStatus.CREATED) == "created"
        assert str(PipelineStatus.RUNNING) == "running"

    def test_flext_pipeline_config_validation(self) -> None:
        """Test FlextPipeline config validation."""
        # Test with valid config
        pipeline_data = {
            "id": "test-id",
            "name": "test-pipeline",
            "description": "Test pipeline",
            "config": {
                "tap": {"name": "tap-postgres"},
                "target": {"name": "target-jsonl"},
            },
            "status": PipelineStatus.CREATED,
            "created_at": datetime.now(UTC),
            "updated_at": datetime.now(UTC),
        }

        pipeline = FlextPipeline(**pipeline_data)
        assert pipeline.config["tap"]["name"] == "tap-postgres"

    def test_flext_pipeline_timestamps(self) -> None:
        """Test FlextPipeline timestamp handling."""
        now = datetime.now(UTC)
        pipeline_data = {
            "id": "test-id",
            "name": "test-pipeline",
            "description": "Test pipeline",
            "config": {},
            "status": PipelineStatus.CREATED,
            "created_at": now,
            "updated_at": now,
        }

        pipeline = FlextPipeline(**pipeline_data)
        assert pipeline.created_at == now
        assert pipeline.updated_at == now


class TestPluginDomainModels:
    """Complete test coverage for plugin domain models - target 95%+."""

    def test_flext_plugin_creation_success(self) -> None:
        """Test successful FlextPlugin creation."""
        plugin_data = {
            "id": "plugin-id",
            "name": "tap-postgres",
            "version": "1.0.0",
            "plugin_type": "tap",
            "status": PluginStatus.INSTALLED,
            "config": {"host": "localhost", "port": 5432},
            "created_at": datetime.now(UTC),
            "updated_at": datetime.now(UTC),
        }

        plugin = FlextPlugin(**plugin_data)

        assert plugin.id == "plugin-id"
        assert plugin.name == "tap-postgres"
        assert plugin.version == "1.0.0"
        assert plugin.plugin_type == "tap"
        assert plugin.status == PluginStatus.INSTALLED
        assert plugin.config == {"host": "localhost", "port": 5432}

    def test_flext_plugin_validation_errors(self) -> None:
        """Test FlextPlugin validation errors."""
        with pytest.raises(ValidationError) as exc_info:
            FlextPlugin()

        errors = exc_info.value.errors()
        required_fields = {
            "id",
            "name",
            "version",
            "plugin_type",
            "status",
            "config",
            "created_at",
            "updated_at",
        }
        error_fields = {error["loc"][0] for error in errors}
        assert required_fields.issubset(error_fields)

    def test_flext_plugin_invalid_version(self) -> None:
        """Test FlextPlugin with invalid version format."""
        plugin_data = {
            "id": "plugin-id",
            "name": "tap-postgres",
            "version": "invalid.version",
            "plugin_type": "tap",
            "status": PluginStatus.INSTALLED,
            "config": {},
            "created_at": datetime.now(UTC),
            "updated_at": datetime.now(UTC),
        }

        # Note: This might not fail depending on validation rules
        plugin = FlextPlugin(**plugin_data)
        assert plugin.version == "invalid.version"

    def test_plugin_status_enum_values(self) -> None:
        """Test PluginStatus enum values."""
        assert PluginStatus.AVAILABLE == "available"
        assert PluginStatus.INSTALLED == "installed"
        assert PluginStatus.RUNNING == "running"
        assert PluginStatus.FAILED == "failed"

    def test_plugin_type_enum_values(self) -> None:
        """Test PluginType enum values."""
        assert PluginType.TAP == "tap"
        assert PluginType.TARGET == "target"
        assert PluginType.TRANSFORM == "transform"
        assert PluginType.ORCHESTRATOR == "orchestrator"

    def test_flext_plugin_config_types(self) -> None:
        """Test FlextPlugin with different config types."""
        # Test with complex nested config
        complex_config = {
            "database": {
                "host": "localhost",
                "port": 5432,
                "credentials": {
                    "username": "user",
                    "password": "pass",
                },
            },
            "options": ["option1", "option2"],
        }

        plugin_data = {
            "id": "plugin-id",
            "name": "tap-postgres",
            "version": "1.0.0",
            "plugin_type": "tap",
            "status": PluginStatus.INSTALLED,
            "config": complex_config,
            "created_at": datetime.now(UTC),
            "updated_at": datetime.now(UTC),
        }

        plugin = FlextPlugin(**plugin_data)
        assert plugin.config["database"]["host"] == "localhost"
        assert plugin.config["options"] == ["option1", "option2"]


class TestAuthModels:
    """Complete test coverage for authentication models - target 95%+."""

    def test_login_request_success(self) -> None:
        """Test successful LoginRequest creation."""
        request_data = {
            "username": "testuser",
            "password": "testpass",
        }

        request = LoginRequest(**request_data)

        assert request.username == "testuser"
        assert request.password == "testpass"

    def test_login_request_validation_errors(self) -> None:
        """Test LoginRequest validation errors."""
        # Test missing password
        with pytest.raises(ValidationError) as exc_info:
            LoginRequest(username="testuser")

        assert "password" in str(exc_info.value)

    def test_login_request_empty_fields(self) -> None:
        """Test LoginRequest with empty fields."""
        with pytest.raises(ValidationError):
            LoginRequest(username="", password="")

    def test_token_response_success(self) -> None:
        """Test successful TokenResponse creation."""
        response_data = {
            "access_token": "test_token",
            "token_type": "bearer",
            "expires_in": 3600,
        }

        response = TokenResponse(**response_data)

        assert response.access_token == "test_token"
        assert response.token_type == "bearer"
        assert response.expires_in == 3600

    def test_user_response_success(self) -> None:
        """Test successful UserResponse creation."""
        response_data = {
            "username": "testuser",
            "roles": ["user", "developer"],
            "is_REDACTED_LDAP_BIND_PASSWORD": False,
            "created_at": datetime.now(UTC),
        }

        response = UserResponse(**response_data)

        assert response.username == "testuser"
        assert response.roles == ["user", "developer"]
        assert response.is_REDACTED_LDAP_BIND_PASSWORD is False

    def test_user_response_REDACTED_LDAP_BIND_PASSWORD_user(self) -> None:
        """Test UserResponse for REDACTED_LDAP_BIND_PASSWORD user."""
        response_data = {
            "username": "REDACTED_LDAP_BIND_PASSWORD",
            "roles": ["REDACTED_LDAP_BIND_PASSWORD", "user"],
            "is_REDACTED_LDAP_BIND_PASSWORD": True,
            "created_at": datetime.now(UTC),
        }

        response = UserResponse(**response_data)

        assert response.is_REDACTED_LDAP_BIND_PASSWORD is True
        assert "REDACTED_LDAP_BIND_PASSWORD" in response.roles


class TestPipelineRequestResponseModels:
    """Complete test coverage for pipeline request/response models - target 95%+."""

    def test_pipeline_create_request_success(self) -> None:
        """Test successful PipelineCreateRequest creation."""
        request_data = {
            "name": "test-pipeline",
            "description": "Test pipeline description",
            "config": {"tap": "tap-postgres", "target": "target-jsonl"},
        }

        request = PipelineCreateRequest(**request_data)

        assert request.name == "test-pipeline"
        assert request.description == "Test pipeline description"
        assert request.config == {"tap": "tap-postgres", "target": "target-jsonl"}

    def test_pipeline_create_request_validation(self) -> None:
        """Test PipelineCreateRequest validation."""
        # Test missing required fields
        with pytest.raises(ValidationError):
            PipelineCreateRequest()

    def test_pipeline_update_request_success(self) -> None:
        """Test successful PipelineUpdateRequest creation."""
        request_data = {
            "description": "Updated description",
            "config": {"tap": "tap-mysql"},
        }

        request = PipelineUpdateRequest(**request_data)

        assert request.description == "Updated description"
        assert request.config == {"tap": "tap-mysql"}

    def test_pipeline_response_success(self) -> None:
        """Test successful PipelineResponse creation."""
        response_data = {
            "id": "pipeline-id",
            "name": "test-pipeline",
            "description": "Test pipeline",
            "status": "created",
            "config": {},
            "created_at": datetime.now(UTC),
            "updated_at": datetime.now(UTC),
        }

        response = PipelineResponse(**response_data)

        assert response.id == "pipeline-id"
        assert response.name == "test-pipeline"
        assert response.status == "created"


class TestPluginRequestResponseModels:
    """Complete test coverage for plugin request/response models - target 95%+."""

    def test_plugin_installation_request_success(self) -> None:
        """Test successful PluginInstallationRequest creation."""
        request_data = {
            "name": "tap-postgres",
            "version": "1.0.0",
            "source": "hub",
        }

        request = PluginInstallationRequest(**request_data)

        assert request.name == "tap-postgres"
        assert request.version == "1.0.0"
        assert request.source == PluginSource.HUB

    def test_plugin_installation_request_validation(self) -> None:
        """Test PluginInstallationRequest validation."""
        with pytest.raises(ValidationError):
            PluginInstallationRequest()

    def test_plugin_installation_response_success(self) -> None:
        """Test successful PluginInstallationResponse creation."""
        response_data = {
            "name": "tap-postgres",
            "version": "1.0.0",
            "status": "installed",
            "path": "/opt/meltano/plugins/tap-postgres",
            "installed_at": datetime.now(UTC),
        }

        response = PluginInstallationResponse(**response_data)

        assert response.name == "tap-postgres"
        assert response.status == "installed"
        assert response.path == "/opt/meltano/plugins/tap-postgres"

    def test_plugin_response_success(self) -> None:
        """Test successful PluginResponse creation."""
        from uuid import uuid4

        response_data = {
            "plugin_id": uuid4(),
            "name": "tap-postgres",
            "plugin_type": "tap",
            "version": "1.0.0",
            "description": "PostgreSQL tap",
            "plugin_status": "installed",
            "source": PluginSource.HUB,
            "configuration": {},
            "updated_at": datetime.now(UTC).isoformat(),
        }

        response = PluginResponse(**response_data)

        assert response.name == "tap-postgres"
        assert response.plugin_type == "tap"

    def test_plugin_source_enum_values(self) -> None:
        """Test PluginSource enum values."""
        assert PluginSource.HUB == "hub"
        assert PluginSource.GITHUB == "github"
        assert PluginSource.PYPI == "pypi"
        assert internal.invalid == "local"


class TestSystemModels:
    """Complete test coverage for system models - target 95%+."""

    def test_health_response_success(self) -> None:
        """Test successful HealthResponse creation."""
        response_data = {
            "status": "healthy",
            "timestamp": datetime.now(UTC),
            "system": {
                "cpu_usage": 50.0,
                "memory_usage": 60.0,
                "disk_usage": 70.0,
            },
        }

        response = HealthResponse(**response_data)

        assert response.status == "healthy"
        assert response.system["cpu_usage"] == 50.0

    def test_health_response_unhealthy(self) -> None:
        """Test HealthResponse for unhealthy system."""
        response_data = {
            "status": "unhealthy",
            "timestamp": datetime.now(UTC),
            "system": {
                "cpu_usage": 95.0,
                "memory_usage": 90.0,
                "disk_usage": 85.0,
            },
            "errors": ["High CPU usage", "Low disk space"],
        }

        response = HealthResponse(**response_data)

        assert response.status == "unhealthy"
        assert "High CPU usage" in response.errors

    def test_metrics_response_success(self) -> None:
        """Test successful MetricsResponse creation."""
        response_data = {
            "cpu_usage": 45.0,
            "memory_usage": 55.0,
            "disk_usage": 65.0,
            "uptime": 3600,
            "active_pipelines": 5,
            "installed_plugins": 10,
        }

        response = MetricsResponse(**response_data)

        assert response.cpu_usage == 45.0
        assert response.uptime == 3600
        assert response.active_pipelines == 5


class TestModelValidation:
    """Test model validation edge cases - target 95%+."""

    def test_negative_numbers_validation(self) -> None:
        """Test validation of negative numbers where inappropriate."""
        # Test metrics with negative values
        with pytest.raises(ValidationError):
            MetricsResponse(
                cpu_usage=-10.0,  # Should not be negative
                memory_usage=50.0,
                disk_usage=30.0,
                uptime=3600,
                active_pipelines=0,
                installed_plugins=0,
            )

    def test_percentage_bounds_validation(self) -> None:
        """Test validation of percentage values."""
        # Test metrics with values over 100%
        with pytest.raises(ValidationError):
            MetricsResponse(
                cpu_usage=150.0,  # Should not exceed 100%
                memory_usage=50.0,
                disk_usage=30.0,
                uptime=3600,
                active_pipelines=0,
                installed_plugins=0,
            )

    def test_string_length_validation(self) -> None:
        """Test string length validation."""
        # Test very long pipeline name
        long_name = "x" * 1000

        # This might not fail depending on validation rules
        try:
            pipeline_data = {
                "id": "test-id",
                "name": long_name,
                "description": "Test pipeline",
                "config": {},
                "status": PipelineStatus.CREATED,
                "created_at": datetime.now(UTC),
                "updated_at": datetime.now(UTC),
            }
            FlextPipeline(**pipeline_data)
        except ValidationError:
            pass  # Expected if validation is in place

    def test_timezone_aware_datetime(self) -> None:
        """Test timezone-aware datetime handling."""
        # Test with timezone-aware datetime
        now_utc = datetime.now(UTC)

        pipeline_data = {
            "id": "test-id",
            "name": "test-pipeline",
            "description": "Test pipeline",
            "config": {},
            "status": PipelineStatus.CREATED,
            "created_at": now_utc,
            "updated_at": now_utc,
        }

        pipeline = FlextPipeline(**pipeline_data)
        assert pipeline.created_at.tzinfo is not None

    def test_optional_fields_defaults(self) -> None:
        """Test optional field defaults."""
        # Test PipelineUpdateRequest with minimal data
        request = PipelineUpdateRequest()

        # Should not raise validation error for empty optional fields
        assert request is not None
